# Role-Based Access Control

Created on 2022-12-23 by Pawe≈Ç Kosiec ([@pkosiec](https://github.com/pkosiec))

| Status                                   |
|------------------------------------------|
| `PROPOSED`                               |

## Overview



<!-- toc -->

  * [Goal](#goal)
  * [Non-goal](#non-goal)
- [Proposal](#proposal)
  * [User Story Name](#user-story-name)
    + [Suggested solution](#suggested-solution)
    + [Alternatives](#alternatives)
- [Consequences](#consequences)

<!-- tocstop -->

### Goal


### Non-goal

## Assumptions
- RBAC support is plugin-specific. Not all executors are based on Kubernetes API.

## Proposal

### Identify users for all communication platforms

Getting group for a given user? Or email?

Slack -> user groups or email
Discord -> roles or email
Mattermost -> group in props???? to check

#### Discord

For message we have roles IDs:
https://discord.com/developers/docs/topics/gateway-events#message-create

##### Roles

Based on that we can query for a full role object to get its name.

```go
b.api.AddHandler(func(s *discordgo.Session, m *discordgo.MessageCreate) {
		msg := discordMessage{
			Event: m,
		}
		roles, _ := b.api.GuildRoles(m.GuildID)
		// manually filter role by ID - unfortunately there's just list capability - couldn't find get
        // we can cache the roles as they are server-wide (or guild-wide, depends what term is used)
		// get role.Name - more: https://discord.com/developers/docs/topics/permissions#role-object
		
```     

##### User email

> The field user won't be included in the member object attached to MESSAGE_CREATE and MESSAGE_UPDATE gateway events.

We need to query user data as they are missing from the message object:

#### MS Teams

Manual mapping of user to group is needed.
Or, channelID?

- there are no user groups
- what about private conversation with bot?
- probably manual user - group mapping is needed on Botkube side

Get user email based on ID:
1. https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/conversations/channel-and-group-conversations?tabs=json#retrieve-mentions
2. Then https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/get-teams-context?tabs=json#get-single-member-details


Or, per channel? We have channel ID here: https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/conversations/channel-and-group-conversations?tabs=json#retrieve-mentions

### Assign roles to users

1. Cluster Admin provides ClusterRoles and ClusterRoleBindings

> Note: Impersonating a user or group allows you to perform any action as if you were that user or group; for that reason, impersonation is not namespace scoped. If you want to allow impersonation using Kubernetes RBAC, this requires using a ClusterRole and a ClusterRoleBinding, not a Role and RoleBinding.

Source: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation


```yaml
rbac:
  groups:
    - name: foo
      subjects:
        - email: foo@example.com
        - email: bar@example.com
    - name: bar
      subjectsFrom: UserGroup
```

Executors:

```yaml
executors:
  'kubectl-read-only':
    botkube/kubectl:
      enabled: true
      config: 
        namespaces:
          include:
              - ".*"
        commands:
            verbs: ["api-resources", "api-versions", "cluster-info", "describe",   "explain", "get", "logs", "top"]
            resources: ["deployments", "pods", "namespaces", "daemonsets",   "statefulsets", "storageclasses", "nodes", "configmaps", "services",   "ingresses"]
        defaultNamespace: default
        restrictAccess: false                
        rbac: &kubectlRBAC
          
  'kubectl-pods-rw':
    botkube/kubectl:
      enabled: true
      config:
        # ...
        rbac: *kubectlCfg # no need to specify it again if it's the same as above
  'kubectl-deploy-rw':
    botkube/kubectl@v1.0.0:
      enabled: true
      config:
        # ...      
        rbac: *kubectlCfg # no need to specify it again if it's the same as above      
```

### Using group access rules






## Alternatives

### Using group access rules

Running executor in a separate container with dedicated ServiceAccount and ClusterRoleBinding - not possible as our plugin system is not compatible:

> While the plugin system is over RPC, it is currently only designed to work over a local reliable network. Plugins over a real network are not supported and will lead to unexpected behavior.
> **Source:** https://github.com/hashicorp/go-plugin

## Consequences
