# Role-Based Access Control

Created on 2022-12-23 by Pawe≈Ç Kosiec ([@pkosiec](https://github.com/pkosiec))

| Status     |
| ---------- |
| `PROPOSED` |

## Overview

Botkube exposes an ability to run arbitrary commands, especially those related to Kubernetes clusters. Currently, to execute any `kubectl` command, Botkube uses ClusterRole which comes with an installation. This ClusterRole is bound to a ServiceAccount used by a Botkube Pod. This raises security concerns.

Also, while Botkube supports per-channel kubectl execution configuration, users should be allowed to set per-user or group mapping for more complex scenarios. While initially we could stick to channel-based grouping, it would be great to have an extensible mechanism to cover future use cases.

<!-- toc -->

<!-- tocstop -->

### Goal

- Stop using ClusterRole assigned to the Botkube pod for executing commands
- Implement ability to configure command execution permissions for different user groups
- Add ability to map users from the communication platforms to Kubernetes permissions
- Ensure that the proposed approach can be used with external identity providers
- Support plugins

### Non-Goals

- Changing RBAC approach for Sources.

  Sources are not related to any specific user or group. They will still use ClusterRole permissions assigned to the Botkube Pod.

### Assumptions

- RBAC support is plugin-specific. Not all executors are based on Kubernetes API.

## Proposal

### User and group identification

// TODO:

### Configure mapping

User creates proper Roles and ClusterRoles, as well as the RoleBindings and ClusterRoleBindings. For example:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-only
subjects:
  - kind: Group # group binding
    name: developers
    apiGroup: rbac.authorization.k8s.io
  - kind: User # user binding
    name: foo@example.com
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: read-only
  apiGroup: rbac.authorization.k8s.io
```

Next, Botkube needs to be aware of such configuration. In order to achieve this, we'll extend our execution configuration. We would support multiple types of mapping:
- user-email based (allows per-user access rights configuration)
- channel-based (allows per-channel access rights configuration)
- user-group based (for supported platforms we'll use user groups or roles; for MS Teams, we'll fallback to channel-based mapping)
- static (allows to impersonate a given user or group every time a given executor is executed regardless the context)

> **NOTE:** Username and groups prefix could be useful in the clusters where OIDC is configured. For example see [this](https://fusionauth.io/blog/2022/02/24/rbac-with-kubernetes-fusionauth) blog post.

```yaml
executors:
  'kubectl-read-only':
    botkube/kubectl:
      enabled: true
      # New field "context" which will be used by Botkube Default Executor
      context:
        kubeconfig: &kubeconfigCtx

            # Option 1: user impersonation using only email address
            mapping:
              type: UserEmail # user email will be used as identifying subject without group
              usernamePrefix: "" # prefix added to the user email fetched from comm platform
              groupsPrefix: "" # not used

            # Option 2: user impersonation using email address and channel name as a group
            mapping:
              type: ChannelName # channel name will be used as identifying subject
              usernamePrefix: "" # prefix added to the user email fetched from comm platform
              groupsPrefix: "" # added to the channel name

            # Option 3: user impersonation using email address and communication platform user group as a group
            mapping:
              type: UserGroupName # user group name will be used as identifying subject
              usernamePrefix: "" # prefix added to the user email fetched from comm platform
              groupsPrefix: "" # added to the user group name

            # Option 4 (default): static impersonation
            mapping:
              type: Static # impersonate as a given group or user every time a given executor is executed
              username: "any" # username to impersonate
              groups: [ "developers" ] # groups to impersonate

      config:
        defaultNamespace: default
        restrictAccess: false

  'kubectl-pods-rw':
    botkube/kubectl:
      enabled: true
      context:
        kubeconfig: &kubeconfigCtx # no need to specify it again if it's the same as above
  'kubectl-deploy-rw':
    botkube/kubectl@v1.0.0:
      enabled: true
      context:
        kubeconfig: &kubeconfigCtx # no need to specify it again if it's the same as above
```

A few remarks:
- Merging different mapping configuration won't not supported and will result in an error.
- If the kubeconfig context is not provided (as a result, `mapping.type` is empty), Botkube won't create a temporary Kubeconfig for a given plugin.

Initially, we'd support only `Static`, `UserEmail` and `ChannelName` mapping types. `UserGroupName` can be added later based on user demand.

### Executing commands as a user or group

To ensure compatibility with our plugin system, we'll use [K8s API user impersonation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) to create a special short-living Kubeconfig to use for a given execution. This will be handled globally by Botkube for all plugins.

We'll extend our gPRC API for executors in the following way:

```proto
message ExecuteRequest {
  // Commands represents the exact command that was specified by the user.
  string command = 1;
  // Configs is a list of Executor configurations specified by users.
  repeated Config configs = 2;

  // New field
  ExecuteContext context = 3;
}

message ExecuteContext {
  string kubeconfig_path = 1;
}
```

This path may be used by the plugin to access Kubernetes cluster in a restricted way.

To ensure no plugin has access to the sensitive configuration data, we will modify the plugin manager to run command with different user and/or group id. Another option is to use Chroot, however that will require root access or some root-less workarounds, and possibly copying/symlinking some system directories to ensure the GRPC server can run.

Fortunately, either way, we have a full control over how the command is run:

```go
	for key, path := range bins {
    // ...

		//nolint:gosec // warns us about 'Subprocess launching with variable', but we are the one that created that variable.
		cmd := exec.Command(path)
		cmd.SysProcAttr = &syscall.SysProcAttr{
      // Botkube binary is ran as uid 1001 and gid 1001; we can:
      // 1. Create a new user/group in the Docker image
      // 2. Restrict access to `/config` directory just for 1001 user/group.
      // 3. Refer the newly created user / group here:
			Credential: &syscall.Credential{
        Uid: ...,
        Gid: ...,
      },
		}

		cli := plugin.NewClient(&plugin.ClientConfig{
			Cmd:              cmd,
      // ...
		})
```

Ideally, for each execution we could create a temporary working directory with a dedicated Kubeconfig file, symlinked plugin assets (e.g. Kubeconfig or Helm binaries) in an isolated environment.

## Reference

See the [RBAC Proof of concept](../investigation/rbac/README.md) to understand what code changes are needed to implement the production solution.

## Alternatives

### Executing commands as a user or group

After identifying the user and/or group, instead of introspection, we could run executor as a short-living separate Pod with a dedicated ServiceAccount and (Cluster)RoleBinding. This way we could use Kubernetes RBAC to restrict access to the cluster, with the isolation provided by Kubernetes. However, this is not possible as our plugin system is not compatible:

> While the plugin system is over RPC, it is currently only designed to work over a local reliable network. Plugins over a real network are not supported and will lead to unexpected behavior.

**Source:** https://github.com/hashicorp/go-plugin

## Consequences

Once the proposal is accepted, the following changes will be made:

- Introduce `executors[name].context` field
- Add required scopes to the communication apps (e.g. Slack) to identify users by email
- Validate executor bindings configuration and return error if kubeconfig RBAC mapping is different for the same bound plugins
- Generate and pass Kubeconfig as a part of Context for each execution of a Kubernetes-related executor
- Modify plugin manager to run plugins in a restricted environment








---

# Notes

### Identify users for all communication platforms

Getting group for a given user? Or email?

Slack -> user groups or email
Discord -> roles or email
Mattermost -> group in props???? to check

#### Slack

We need two scopes

- `users:read`
- `users:read.email`

```
{
    ...
    InnerEvent: slackevents.EventsAPIInnerEvent{
        Type: "app_mention",
        Data: &slackevents.AppMentionEvent{
        Type: "app_mention",
        User: "U03P93G5BJQ",
        Text: "<@U042QS706CS> get po",
        TimeStamp: "1671697213.467259",
        Channel: "C04CR41HBCN",
        EventTimeStamp: "1671697213.467259",
        },
    },
}
```

#### User groups

Unfortunately Slack user groups are in paid plan, so I cannot test getting user group info. I think we'll need one additional call to get user group details to get its name.

#### Mattermost

```
map[string]interface {}{
  "channel_display_name": "Town Square",
  "channel_name": "town-square",
  "channel_type": "O",
  "mentions": "[\"jta9mx8p6pfiieakry5xq8tq3e\"]",
  "post": "{\"id\":\"gxuats5nfpnk7pu54jgjuaxr7c\",\"create_at\":1671696895130,\"update_at\":1671696895130,\"edit_at\":0,\"delete_at\":0,\"is_pinned\":false,\"user_id\":\"3xpqjecqff8tubxmfmtop8sg6o\",\"channel_id\":\"hswrmknnmfnuxdi81zdaj74coc\",\"root_id\":\"\",\"original_id\":\"\",\"message\":\"@botkube get po\",\"type\":\"\",\"props\":{\"disable_group_highlight\":true},\"hashtags\":\"\",\"pending_post_id\":\"3xpqjecqff8tubxmfmtop8sg6o:1671696894899\",\"reply_count\":0,\"last_reply_at\":0,\"participants\":null,\"metadata\":{}}",
  "sender_name": "@pawel.kosiec",
  "set_online": true,
  "team_id": "fn5ee1ub8frdd8jpkphe1i614y",
}
```

Based on user ID we can get the group:
https://api.mattermost.com/#tag/groups/operation/GetGroupsByUserId

#### Discord

For message we have roles IDs:
https://discord.com/developers/docs/topics/gateway-events#message-create

##### Roles

In the message we have:

```
&discordgo.MessageCreate{
  Message: &discordgo.Message{
    ID: "1055393756033069076",
    ChannelID: "976789916447019068",
    GuildID: "976789763862454284",
    Content: "My watch begins for cluster 'gke-playground'! :crossed_swords:",
    Timestamp: time.Time{},
    MentionRoles: []string{},
    Author: &discordgo.User{
      ID: "976786722706821120",
      Username: "Botkube",
      Avatar: "8c1378358e9c52d1e142509e8f4fa1dd",
      Discriminator: "7507",
      Bot: true,
    },
    Attachments: []*discordgo.MessageAttachment{},
    Components: []discordgo.MessageComponent{},
    Embeds: []*discordgo.MessageEmbed{},
    Mentions: []*discordgo.User{},
    Member: &discordgo.Member{
      JoinedAt: time.Time{},
      Roles: []string{
        "976789858670497805", // <-- this is what we can use
      },
    },
  },
}
```

Based on that we can query for a full role object to get its name.

```go
b.api.AddHandler(func(s *discordgo.Session, m *discordgo.MessageCreate) {
		msg := discordMessage{
			Event: m,
		}
		roles, _ := b.api.GuildRoles(m.GuildID)
		// manually filter role by ID - unfortunately there's just list capability - couldn't find get
        // we can cache the roles as they are server-wide (or guild-wide, depends what term is used)
		// get role.Name - more: https://discord.com/developers/docs/topics/permissions#role-object

```

##### User email

> The field user won't be included in the member object attached to MESSAGE_CREATE and MESSAGE_UPDATE gateway events.

We need to query user data as they are missing from the message object:

#### MS Teams

Manual mapping of user to group is needed.
Or, channelID?

- there are no user groups
- what about private conversation with bot?
- probably manual user - group mapping is needed on Botkube side

Get user email based on ID:

1. https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/conversations/channel-and-group-conversations?tabs=json#retrieve-mentions
2. Then https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/get-teams-context?tabs=json#get-single-member-details

Or, per channel? We have channel ID here: https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/conversations/channel-and-group-conversations?tabs=json#retrieve-mentions



## Consequences

## To do

- RBAC for other plugins

- Helm - custom Go implementation - introspection possible
  - Has --kube-as-user --kube-as-group, so we can use the binary
  -

plugin has always kubeconfig which is used
create temporary kubeconfig

chroot - directory isolation first
process isolation later

kubernetes RBAC plugin-wide

different user has access to different kubeconfig
create a workdir, generate kubeconfig and copy binary to a workdir per execution?
