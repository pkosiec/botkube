# Role-Based Access Control

Created on 2022-12-23 by Pawe≈Ç Kosiec ([@pkosiec](https://github.com/pkosiec))

| Status                                   |
|------------------------------------------|
| `PROPOSED`                               |

## Overview

Botkube exposes an ability to run arbitrary commands, especially those related to Kubernetes clusters. Currently, to execute any `kubectl` command, Botkube uses ClusterRole which comes with an installation. This ClusterRole is bound to a ServiceAccount used by a Botkube Pod. This raises security concerns.

Also, while Botkube supports per-channel kubectl execution configuration, users should be allowed to set per-user mapping for more complex scenarios. 

<!-- toc -->

  * [Goal](#goal)
  * [Non-goal](#non-goal)
- [Proposal](#proposal)
  * [User Story Name](#user-story-name)
    + [Suggested solution](#suggested-solution)
    + [Alternatives](#alternatives)
- [Consequences](#consequences)

<!-- tocstop -->

### Goal

- Stop using ClusterRole assigned to the Botkube pod for executing commands
- Implement ability to configure command execution permissions for different user groups
- Add ability to map users from the communication platforms to Kubernetes permissions
- Allow using external identity providers to configure the mapping

## Assumptions
- RBAC support is plugin-specific. Not all executors are based on Kubernetes API.

## Proposal

### Identify users for all communication platforms

Getting group for a given user? Or email?

Slack -> user groups or email
Discord -> roles or email
Mattermost -> group in props???? to check


#### Slack

We need two scopes
- `users:read`
- `users:read.email`


```
{
    ...
    InnerEvent: slackevents.EventsAPIInnerEvent{
        Type: "app_mention",
        Data: &slackevents.AppMentionEvent{
        Type: "app_mention",
        User: "U03P93G5BJQ",
        Text: "<@U042QS706CS> get po",
        TimeStamp: "1671697213.467259",
        Channel: "C04CR41HBCN",
        EventTimeStamp: "1671697213.467259",
        },
    },    
}
```

#### User groups

Unfortunately Slack user groups are in paid plan, so I cannot test getting user group info. I think we'll need one additional call to get user group details to get its name.


#### Mattermost

```
map[string]interface {}{
  "channel_display_name": "Town Square",
  "channel_name": "town-square",
  "channel_type": "O",
  "mentions": "[\"jta9mx8p6pfiieakry5xq8tq3e\"]",
  "post": "{\"id\":\"gxuats5nfpnk7pu54jgjuaxr7c\",\"create_at\":1671696895130,\"update_at\":1671696895130,\"edit_at\":0,\"delete_at\":0,\"is_pinned\":false,\"user_id\":\"3xpqjecqff8tubxmfmtop8sg6o\",\"channel_id\":\"hswrmknnmfnuxdi81zdaj74coc\",\"root_id\":\"\",\"original_id\":\"\",\"message\":\"@botkube get po\",\"type\":\"\",\"props\":{\"disable_group_highlight\":true},\"hashtags\":\"\",\"pending_post_id\":\"3xpqjecqff8tubxmfmtop8sg6o:1671696894899\",\"reply_count\":0,\"last_reply_at\":0,\"participants\":null,\"metadata\":{}}",
  "sender_name": "@pawel.kosiec",
  "set_online": true,
  "team_id": "fn5ee1ub8frdd8jpkphe1i614y",
}
```

Based on user ID we can get the group:
https://api.mattermost.com/#tag/groups/operation/GetGroupsByUserId

#### Discord

For message we have roles IDs:
https://discord.com/developers/docs/topics/gateway-events#message-create

##### Roles

In the message we have:

```
&discordgo.MessageCreate{
  Message: &discordgo.Message{
    ID: "1055393756033069076",
    ChannelID: "976789916447019068",
    GuildID: "976789763862454284",
    Content: "My watch begins for cluster 'gke-playground'! :crossed_swords:",
    Timestamp: time.Time{},
    MentionRoles: []string{},
    Author: &discordgo.User{
      ID: "976786722706821120",
      Username: "Botkube",
      Avatar: "8c1378358e9c52d1e142509e8f4fa1dd",
      Discriminator: "7507",
      Bot: true,
    },
    Attachments: []*discordgo.MessageAttachment{},
    Components: []discordgo.MessageComponent{},
    Embeds: []*discordgo.MessageEmbed{},
    Mentions: []*discordgo.User{},
    Member: &discordgo.Member{
      JoinedAt: time.Time{},
      Roles: []string{
        "976789858670497805", // <-- this is what we'll use
      },
    },
  },
}
```

Based on that we can query for a full role object to get its name.

```go
b.api.AddHandler(func(s *discordgo.Session, m *discordgo.MessageCreate) {
		msg := discordMessage{
			Event: m,
		}
		roles, _ := b.api.GuildRoles(m.GuildID)
		// manually filter role by ID - unfortunately there's just list capability - couldn't find get
        // we can cache the roles as they are server-wide (or guild-wide, depends what term is used)
		// get role.Name - more: https://discord.com/developers/docs/topics/permissions#role-object
		
```     

##### User email

> The field user won't be included in the member object attached to MESSAGE_CREATE and MESSAGE_UPDATE gateway events.

We need to query user data as they are missing from the message object:

#### MS Teams

Manual mapping of user to group is needed.
Or, channelID?

- there are no user groups
- what about private conversation with bot?
- probably manual user - group mapping is needed on Botkube side

Get user email based on ID:
1. https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/conversations/channel-and-group-conversations?tabs=json#retrieve-mentions
2. Then https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/get-teams-context?tabs=json#get-single-member-details


Or, per channel? We have channel ID here: https://learn.microsoft.com/en-us/microsoftteams/platform/bots/how-to/conversations/channel-and-group-conversations?tabs=json#retrieve-mentions

### Assign roles to users

1. Cluster Admin provides ClusterRoles and ClusterRoleBindings

> Note: Impersonating a user or group allows you to perform any action as if you were that user or group; for that reason, impersonation is not namespace scoped. If you want to allow impersonation using Kubernetes RBAC, this requires using a ClusterRole and a ClusterRoleBinding, not a Role and RoleBinding.

Source: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation


```yaml
rbac:
  groups:
    - name: foo
      subjects:
        - email: foo@example.com
        - email: bar@example.com
    - name: bar
      subjectsFrom: UserGroup
```

Executors:

```yaml
executors:
  'kubectl-read-only':
    botkube/kubectl:
      enabled: true
      config: 
        namespaces:
          include:
              - ".*"
        commands:
            verbs: ["api-resources", "api-versions", "cluster-info", "describe",   "explain", "get", "logs", "top"]
            resources: ["deployments", "pods", "namespaces", "daemonsets",   "statefulsets", "storageclasses", "nodes", "configmaps", "services",   "ingresses"]
        defaultNamespace: default
        restrictAccess: false                
        rbac: &kubectlRBAC
          
  'kubectl-pods-rw':
    botkube/kubectl:
      enabled: true
      config:
        # ...
        rbac: *kubectlCfg # no need to specify it again if it's the same as above
  'kubectl-deploy-rw':
    botkube/kubectl@v1.0.0:
      enabled: true
      config:
        # ...      
        rbac: *kubectlCfg # no need to specify it again if it's the same as above      
```

### Using group access rules






## Alternatives

### Using group access rules

Running executor in a separate container with dedicated ServiceAccount and ClusterRoleBinding - not possible as our plugin system is not compatible:

> While the plugin system is over RPC, it is currently only designed to work over a local reliable network. Plugins over a real network are not supported and will lead to unexpected behavior.
> **Source:** https://github.com/hashicorp/go-plugin

## Consequences

## To do

- RBAC for other plugins

- Helm - custom Go implementation - introspection possible
    - Has --kube-as-user --kube-as-group, so we can use the binary
    - 
- The easiest way - probably spawn a second container for command execution with bound a proper SA
   - This doesn't fit nicely into our plugin system


plugin has always kubeconfig which is used
create temporary kubeconfig


chroot - directory isolation first
process isolation later

kubernetes RBAC plugin-wide

https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation

different user has access to different kubeconfig
create a workdir, generate kubeconfig and copy binary to a workdir per execution?
